{% extends "layouts/standard-layout.njk" %}

{% block embedded_css %}
<style>
h1::before {
  content: "Docs";
}
h2:first-of-type::before {
  counter-increment: section;
  content: "Method: " counter(section);
}
body {
  counter-reset: section;
}
</style>
{% endblock %}

{% block main %}
<section id="intro">
  <h2>Separation</h2>
  <p>Keeping markup and presentation separate makes life easier going forward. There are many benefits, the primary benefit being that changes can be made using <strong><u>only</u></strong> CSS.</p>
</section>
<section id="main">
  <h5>Don't set things in stone</h5>
  <p>Describing in markup the appearance of anything limits what may be altered later.</p>
  <h6>Example</h6>
  <div class="grid layout-1">
    <div>
      <p>In figure 1 the classes are descriptive of how many columns they span. This is fine until something requires an update, if the width needs to change you have no choice—if you want your markup to be semantic—but to change the markup.</p>
    </div>
    <div>
      <figure>
        {% include "../partials/code-samples/col-scss-set-in-stone.njk" %}
      <figcaption>Figure 1</figcaption>
      </figure>
    </div>
  </div>
  {# Choice #}
  <h5>Choice</h5>
  <div class="grid layout-1">
    <div>
      <p>You could either change both HTML and CSS, change HTML only—but be limited by existing styles—or change CSS only.</p>
      <h6>Example</h6>
      <p>If you keep your markup <strong>generic</strong> this change could be a matter of updating the CSS only. In figure 2 the generic <code class="code-inline language-markup">&lt;div&gt;</code> tag replaces the specific <code class="code-inline language-markup">&lt;div class="col-4"&gt;</code> &amp; <code class="code-inline language-markup">&lt;div class="col-6"&gt;</code> tags.</p>
    </div>
    <div>
      <figure>
        {% include "../partials/code-samples/col-scss-layout-1.njk" %}
      <figcaption>Figure 2</figcaption>
      </figure>
    </div>
  </div>
</section>
<section id="grid" class="section">
  <h2>Using the grid</h2>
  <p>As detailed in <a href="http://codepen.io/morganfeeney/post/dont-build-bootstrap-style-grid-systems-with-flexbox" target="_blank">my article</a>,
   what I learnt from the first incarnation of Interior—which was based on Bootstrap—is that you have to walk away as much as possible from what came before,
    and embrace the new tools for layout. Interior v2 doesn't rely on floats for laying out columns, it never will, instead the focus is on using <a href="grid.html">mixins</a> to create them, whilst allowing vanilla Flexbox to do the layout.</p>
  <h5>Flexbox is the framework</h5>
  <p>In a nutshell what I realised was that I just need to create a grid and gutters, flexbox does the rest. So that's how it works in Interior v2.</p>
  <blockquote class="outset-right">
    <p>I just need to create a grid and gutters, flexbox does the rest.</p>
    <cite><a href="http://codepen.io/morganfeeney/post/dont-build-bootstrap-style-grid-systems-with-flexbox">Moi</a></cite>
  </blockquote>
  <p>Who knows what i will learn from the new Grid spec and what v3 will be but I'm guessing there may not be a need to use Interior for grid layout, yet there will be a benefit to automation using Scss—so Interior will live on—albeit <em>in a state of evolution</em>.</p>
</section>
{% endblock %}

{% block aside %}{% endblock %}
